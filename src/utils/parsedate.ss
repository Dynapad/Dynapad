(require (lib "date.ss"))
; offers:
; (date->string <date>)
; (date-display-format 'american | 'chinese | 'iso-8601 | 'rfc2822 | ...)
; (find-seconds sec min hour day month year)

; The date- struct has following fields:
; date-second
; date-minute
; date-hour
; date-day
; date-month
; date-year
; date-week-day (0-6)
; date-year-day 
; date-dst? (bool)
; date-time-zone-offset

; This file offers complementary fns:
; (string->date "Thurs Nov 11 12:34:56 1999") --> date
; (infer-complete-date date) --> date

; Parses strings like
; Thu, Jan  9th, 17:37:06 2003
; into list (year month day hour min sec)
(define *weekday-pattern* "([A-Z][a-z.]+)?,? *")
(define *weekday-rexp* (regexp *weekday-pattern*))
(define *month-pattern* "([A-Z][a-z.]+) *")
(define *month-rexp* (regexp *month-pattern*))
(define *day-pattern* "([0-9]+)[a-z]*,? *")
(define *day-rexp* (regexp *day-pattern*))
(define *hourminsec-pattern* "([0-9]+):([0-9]+):?([0-9]*) *")
(define *hourminsec-rexp* (regexp *hourminsec-pattern*))
(define *year-pattern* "([0-9][0-9][0-9][0-9]) ?")
(define *year-rexp* (regexp *year-pattern*))


(dynaload "tools-lists.ss") ;need list-position-general
(define string->month #f)
(let ((months-rexp (regexp "(Jan)|(Feb)|(Mar)|(Apr)|(May)|(Jun)|(Jul)|(Aug)|(Sep)|(Oct)|(Nov)|(Dec)")))
  (set! string->month
    (lambda (str)
      (and str
           (let ((match (regexp-match months-rexp str)))
         (and match
              (let ((pos (list-position-general (cdr match) #f
                            (lambda (x y) y))))
            (and pos (+ 1 pos)))))))))

(define string->weekday #f)
(let ((weekdays-rexp (regexp "(Su)|(M)|(Tu)|(W)|(Th)|(F)|(Sa)")))
  (set! string->weekday
    (lambda (str)
      (and str
           (let ((match (regexp-match weekdays-rexp str)))
         (and match
              (let ((pos (list-position-general (cdr match) #f (lambda (x y) y))))
            pos)))))))

(define *parse-date-special-rexp*
  (regexp (format "~a~a~a~a"
          *day-pattern*
          *month-pattern*
          *year-pattern*
          *hourminsec-pattern*)))
(define *parse-date-rexp* (regexp
               (format "~a~a~a(~a)?~a?"
                   *weekday-pattern*
                   *month-pattern*
                   *day-pattern*
                   *hourminsec-pattern*
                   *year-pattern*)))

(define (string->date str)
; given string like "Thu, Jan. 9th, 17:37:06 2003" (generated by pdfinfo, e.g.)
;returns date struct;
; any missing fields are left #f; may be completed with (infer-complete-date ...)
  (let ((special-match (regexp-match *parse-date-special-rexp* str))
    (match (regexp-match *parse-date-rexp* str)))
    (or (and special-match
         (mlet (((day mon year hour min sec) (cdr special-match)))
           (make-date (ensure-number sec)
                  (ensure-number min)
                  (ensure-number hour)
                  (ensure-number day)
                  (string->month mon)
                  (ensure-number year)
                  1 ;weekday (ignored?)
                  #f #f #f))) ;day-of-year, dst?, timezone
    (and match
         (mlet (((wkday mon day time hour min sec year) (cdr match)))
;           (when (and (> (ensure-number day) 1000)
;              (< (ensure-number year) 1900))
;             (let ((temp day))
;               (set! day year)
;               (set! year temp)))
           (make-date (ensure-number sec)
                  (ensure-number min)
                  (ensure-number hour)
                  (ensure-number day)
                  (string->month mon)
                  (ensure-number year)
                  (string->weekday wkday)
                  #f #f #f))) ;day-of-year, dst?, timezone
    )))

;      (let* ((mon-day-hr-min-sec-yr (cddr match))
;         (monthstr (car mon-day-hr-min-sec-yr))
;         (junk (set-car! mon-day-hr-min-sec-yr (string->month monthstr)))
;         (yr-sec-min-hr-day-mon (reverse mon-day-hr-min-sec-yr))
;         (year (car yr-sec-min-hr-day-mon))
;         (sec-min-hr-day-mon (map ensure-number (cdr yr-sec-min-hr-day-mon))))
;        (eval `(make-date ,@sec-min-hr-day-mon
;                  ,(ensure-number year)
;                  ,(string->weekday (cadr match)) ;weekday
;                  #f #f #f))))))  ;day-of-year, dst?, timezone

(define (date->seconds date)
  (and date (apply find-seconds (date->list date))))

(define (current-year)
  (date-year (seconds->date (current-seconds))))

(define (list->date sec min hr day mon yr)
  (make-date sec min hr day mon yr #f #f #f #f))

(define (date->list date)
; returns (sec min hr day mon yr)
  (list (date-second date)
    (date-minute date)
    (date-hour date)
    (date-day date)
    (date-month date)
    (date-year date)))

(define (infer-complete-date date)
;fills in missing fields (except for dst?, time-zone-offset)
  (and date
       (let* ((sec  (or (date-second date) 0))
          (min  (or (date-minute date) 0))
          (hour (or (date-hour date) 0))
          (day  (or (date-day date) 1))
          (mon  (or (date-month date) 1))
          (year (or (date-year date) (current-year))); assume this year; may be too bold...
          (totalsec (find-seconds sec min hour day mon year)))
     (seconds->date totalsec))))


; proprietary date->string formats:
(define month/number->abbrev
  (lambda (x)
    (case x
      [(12) "Dec"] [(1) "Jan"]  [(2) "Feb"]
      [(3) "Mar"]     [(4) "Apr"]    [(5) "May"]
      [(6) "Jun"]      [(7) "Jul"]     [(8) "Aug"]
      [(9) "Sep"] [(10) "Oct"] [(11) "Nov"]
      [else ""])))

; Usage Example:
; (def short-date (string->date "Dec 8"))
; (def full-date (infer-complete-date short-date))
; (date->string full-date)  --> "Wednesday, December 8th, 2004"

; ---- string pruning: stripping away fields from result of date->string
; need separate regexp for each printing format...
; iso-8601:   "YYYY-MM-DD hh:mm:ss"
(define *iso-date-format-rexp*
  (regexp "()(....)(-)(..)(-)(..)( +)0?([^0]?.)(:)(..)(:)(..)"))
; american:   
;(define *american-date-format-rexp*
;  (regexp "([A-Za-z]+, )([0-9]+)( )([A-Za-z]+)( )([0-9a-z]+)(, )(....)( )([0-9]+)(:)([0-9]+)(:)([0-9]+)([a-z])"))

(define (prune-date-string template format-rexp datestr)
  ;for each non-#f in template (list) includes corresponding field
; OR PERHAPS...
 ; template is one of several symbols: eg. 'MDh --> include month, day, hour
  (let ((matches (regexp-match format-rexp datestr)))
    (and matches
     (let* ((full-template
         (apply append
            (map list template template)))
;     (junk (say full-template))
;     (junk2 (say (cdr matches)))
;     (junk3 (say (length (cdr matches))))
        (keepstr-list
         (apply append
            (map (lambda (t s) (if t (list s) null))
                 full-template
                 (cdr matches)))))
       (if (null? keepstr-list)
           ""
           (apply string-append (cdr keepstr-list)))))))
